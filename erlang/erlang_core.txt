%% vim: ft=erlang :


%%-----------------------------------------------------------------------------
%% these 4 operators are "right to left" (++, --, !, =)
%%-----------------------------------------------------------------------------
[1,2,3] -- [1,2,3,4,5] -- [1,2].
%> [1,2]

([1,2,3] -- [1,2,3,4,5]) -- [1,2].
%> []


%%-----------------------------------------------------------------------------
%% the "if" in erlang only support guard, so it only have limited power.
%%-----------------------------------------------------------------------------
A = fun() -> true end.
%> #Fun<erl_eval.20.54118792>

if A() -> 1; true -> 2 end. % user defined function is not allow in "if"
%> * 1: illegal guard expression

%% "if" is not necessary in erlang, for example,
if N > 0 -> positive end.
%% is just like:
case dummy of _ when N > 0 -> positive end.


%%-----------------------------------------------------------------------------
%% Guard is constructed by "guard sequence" (seprated by ";"), "guard sequence"
%% is constructed by "guard expressions" (seprated by ",").
%%
%% In other words, ";" is like "or" in guard, "," is like "and",
%% and "," has higher priority
%%-----------------------------------------------------------------------------
X = fun(A) when A > 3, A < 5; A > 8, A < 10 -> A end.
%> #Fun<erl_eval.6.128620087>

X(1).
%> ** exception error: no function clause matching

X(4).
%> 4

X(6).
%> ** exception error: no function clause matching

X(9).
%> 9

X(11).
%> ** exception error: no function clause matching


%%-----------------------------------------------------------------------------
%% character
%% Erlang has no character or string, it's integer and list.
%%-----------------------------------------------------------------------------
$c.
%> 99

$\r.
%> 13

$\n.
%> 10

[$a|"bcd"].
%> "abcd"

["a"|"bcd"].
%> ["a", 98, 99, 100]


%%-----------------------------------------------------------------------------
%% element & lists:nth, one for list, one for tuple
%%    nth is not built-in, because usually, you should not use nth, it's slow
%%
%% but for tuple, select element through index is fast and normal,
%% so `element(N, L)` is built-in.
%%-----------------------------------------------------------------------------
lists:nth(2, [a, b, c, d, e]).
%> b

element(2, {a, b, c, d, e}).
%> b


%%-----------------------------------------------------------------------------
%% there is no "reduce" in erlang, it's called "fold"
%%-----------------------------------------------------------------------------
lists:foldl(fun(X, V) -> [X | V] end, [], [1,2,3]).
%> [3,2,1]

lists:foldr(fun(X, V) -> [X | V] end, [], [1,2,3]).
%> [1,2,3]


%%-----------------------------------------------------------------------------
%% SYNTAX SUGAR of map
%% Suggestion:
%%      use "=>" only when you want to create a new map
%%      use ":=" when possible
%%-----------------------------------------------------------------------------
%% create:
Me = #{ name => "wittyfox", age => 19 }.
%> #{age => 19,name => "wittyfox"}

%% update:
New_Me = Me#{ age => 20 }.
%> #{age => 20,name => "wittyfox"}

%% if you write a wrong key:
Me#{ aeg => 20 }.
%> #{aeg => 20,age => 19,name => "wittyfox"}

%% if you do NOT want to add element by accident, use ":=" instead of "=>"
Me#{ aeg := 20 }.
%> ** exception error: {badkey,aeg}
%    in function  maps:update/3
%       called as maps:update(aeg,20,#{age => 19,name => "wittyfox"})

%% pattern match: use ":=" only
#{ age := Age } = Me.
%> #{age => 19,name => "wittyfox"}
Age.
%> 19


%%-----------------------------------------------------------------------------
%% FUNCTIONS of map
%%-----------------------------------------------------------------------------
%% create:
maps:new() % no argument
%> #{}

%% get all keys:
maps:keys(Me)
%> [age,name]

%% get all values:
maps:values(Me)
%> [19,"wittyfox"]

%% check key existence
maps:is_key(age, Me).
%> true

maps:is_key(aeg, Me).
%> false

%% size, maps:size uses erlang:map_size
maps:size(Me).
%> 2

map_size(Me).
%> 2

%% get value from key
maps:get(age, Me).
%> 19
maps:get(aeg, Me).
%> ** exception error: {badkey,aeg}

%% get value from key with default value when key does not exist
maps:get(aeg, Me, 20).
%> 20

%% find can do this, too
maps:find(age, Me).
%> {ok, 19}

maps:find(aeg, Me).
%> error


%% update map like "=>"
maps:put(gender, male, Me).
%> #{age => 19,gender => male,name => "wittyfox"}


%% update map like ":="
maps:update(gender, male, Me).
%> ** exception error: {badkey,gender}

maps:update(age, 20, Me).
%> #{age => 20,name => "wittyfox"}


%% remove a set, will NOT raise exception even if the key does not exist
maps:remove(age, Me).
%> #{name => "wittyfox"}


%% merge two map
maps:merge(Me, #{ age => 10 }).
%> #{age => 10,name => "wittyfox"}

%% it's just like:
Me#{ age => 10 }.

%% transfrom between map and list
maps:to_list(Me).
%> [{age,19},{name,"wittyfox"}]

maps:from_list([{name, "wittyfox"}, {age, 19}]).
%> #{age => 19,name => "wittyfox"}


%%-----------------------------------------------------------------------------
%% "map", "fold", "with", "without"
%% use "maps:to_list/1" transform to list and handle things as list, then
%% use "maps:from_list/1" transform back to map.
%%-----------------------------------------------------------------------------
maps:map(fun (X, Y) -> io:format("~p => ~p~n", [X, Y]) end, Me).
%> age => 19
%  name => "wittyfox"
%  #{age => ok,name => ok}

maps:fold(fun (X, Y, V) -> V + 1 end, 0, Me).
%> 2


%% select part of a map
maps:with([], Me).
%> #{}

maps:with([age], Me).
%> #{age => 19}

% non-exist key is accepted
maps:with([aeg], Me).
%> #{}

maps:without([], Me).
%> #{age => 19,name => "wittyfox"}

maps:without([age], Me).
%> #{name => "wittyfox"}

% non-exist key is accepted
maps:without([age, neme], Me).
%> #{name => "wittyfox"}


%%-----------------------------------------------------------------------------
%% list > tuple > atom > number
%%-----------------------------------------------------------------------------
[1, 2, 3] > {1, 2, 3}
%> true

lists:sort([a, b, "abc", {1,2,3}, 5]).
%> [5,a,b,{1,2,3},"abc"]


%%-----------------------------------------------------------------------------
%% pre-defined macros: ?MODULE, ?FILE, ?LINE
%%-----------------------------------------------------------------------------


%%-----------------------------------------------------------------------------
%% qlc
%% `qlc:q` is not a real function, it is a parse_transform
%%-----------------------------------------------------------------------------
%% To use `qlc:q` the following compile option is needed in the source file:
-compile({parse_transform,qlc})

QH = qlc:q([{X,Y} || X <- [a,b], Y <- [1,2]]).
%> {qlc_handle,{qlc_lc,#Fun<erl_eval.20.128620087>,
%                      {qlc_opt,false,false,-1,any,[],any,524288,allowed}}}

qlc:e(QH).
%> [{a,1},{a,2},{b,1},{b,2}]

qlc:q([{a,1},{a,2},{b,1},{b,2}]).
%> ** exception error: bad argument


%%-----------------------------------------------------------------------------
%% binary
%% !!
%% a binary field without size is only allowed at the end of a binary pattern
%%
%%-----------------------------------------------------------------------------
<<1, 2, A:2/binary, B/binary>> = <<1, 2, 3, 4, 5, 6, 7, 8>>.
%> <<1,2,3,4,5,6,7,8>>

A.
%> <<3,4>>

B.
%> <<5,6,7,8>>

%% These 2 are similar: (both of them are friendly for recursion)
<<A, B, C/binary>>, [A, B | C]


%%-----------------------------------------------------------------------------
%% the AST of a function
%%-----------------------------------------------------------------------------
%% function contains clauses, a clause is like:
%%  {clause, Line, [Args], [GuardSeqs], [Body]}

F = "blah([A | B]) when A > 0, A < 5; A > 9, A < 11 -> B * 3.".

erl_parse:parse_form(element(2, erl_scan:string(F))).
%> {ok,{function,1,blah,1,
%       [{clause,1,
%         [{cons,1,{var,1,'A'},{var,1,'B'}}],
%         [[{op,1,'>',{var,1,'A'},{integer,1,0}},
%           {op,1,'<',{var,1,'A'},{integer,1,5}}],
%          [{op,1,'>',{var,1,'A'},{integer,1,9}},
%           {op,1,'<',{var,1,'A'},{integer,1,11}}]],
%         [{op,1,'*',{var,1,'B'},{integer,1,3}}]}]}}

erl_parse:parse_form(element(2, erl_scan:string("blah() -> 3."))).
%> {ok,{function,1,blah,0,[{clause,1,[],[],[{integer,1,3}]}]}}


%%-----------------------------------------------------------------------------
%% try...of...catch...after...end
%%-----------------------------------------------------------------------------
%% There can be multiple expressions in try, which is invalid in case:
case 1,2,3,4,5 of 5 -> true end.
%> * 1: syntax error before: ','

try 1,2,3,4,5 of 5 -> true catch _ -> error end.
%> true

%% try can not be used without after or catch
try 1 of 1 -> true end.
%> * 1: syntax error before: 'end'

try 1 of 1 -> true catch _ -> error end.
%> true


%% In try...of...catch...after...
%% the "after" part will always be executed, even if the "of" part
%% or "catch" part raises an exception.
try 1/0
catch error:_ -> nothing
after io:format("<<<after printing>>>~n")
end.
%> <<<after printing>>>
%  nothing

try 1/0
catch error:_ -> 1/0
after io:format("<<<after printing>>>~n")
end.
%> <<<after printing>>>
%  ** exception error: an error occurred when evaluating an arithmetic expression


%% In core erlang,
%% a "try" with "after" is compiled a "try" with "catch".
%% e.g. try A() after B() end  -->  try A(), B() catch B() end
%%
%% And a "try" with both "catch" and "after"
%% is compiled into 2 "try" (nested).


%% In other languages who don't have the "of" part, the exception could be
%% thrown by any expression in the "try" part.
%% Erlang solved some of this problem by introducing the "of" part.
%%
%% When "catch" part is evaluated, you are sure that:
%% 1. the exception is not thrown by the "of" part.
%% 2. the "of" part is not evaluated.
%%
%% Because exceptions in "of" part will not be caught by "catch" part.
%%
try 1/0 of _ -> 1 catch error:Any -> Any end.
%> badarith

try 1 of _ -> 1/0 catch error:Any -> Any end.
%> ** exception error: an error occurred when evaluating an arithmetic expression


%%-----------------------------------------------------------------------------
%% Since R17, "fun" can have name. (good for defining recursive function)
%%-----------------------------------------------------------------------------
F = fun X(0) -> 1; X(N) -> N * X(N - 1) end.
%> #Fun<erl_eval.30.128620087>

F(10).
%> 3628800


