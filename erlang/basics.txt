%% vim: ft=erlang :
%%-----------------------------------------------------------------------------
%% these 4 operators are "right to left" (++, --, !, =)
%%-----------------------------------------------------------------------------
[1,2,3] -- [1,2,3,4,5] -- [1,2].
%> [1,2]

([1,2,3] -- [1,2,3,4,5]) -- [1,2].
%> []


%%-----------------------------------------------------------------------------
%% Create tuple of certain arity
%%-----------------------------------------------------------------------------
erlang:make_tuple(5, 1).
%> {1,1,1,1,1}

erlang:make_tuple(5, d, [{1,a},{3,z}]).
%> {a,d,z,d,d}


%%-----------------------------------------------------------------------------
%% Atom, Variable, funtion call
%%-----------------------------------------------------------------------------
%% both operands of the ':' operator can be variable
VarModName:VarFunName().


%%-----------------------------------------------------------------------------
%% the "if" in erlang only support guard, so it only have limited power.
%%-----------------------------------------------------------------------------
A = fun() -> true end.
%> #Fun<erl_eval.20.54118792>

if A() -> 1; true -> 2 end. % user defined function is not allow in "if"
%> * 1: illegal guard expression

%% "if" is not necessary in erlang, for example,
if N > 0 -> positive end.
%% is just like:
case dummy of _ when N > 0 -> positive end.


%%-----------------------------------------------------------------------------
%% Guard is constructed by "guard sequence" (seprated by ";"), "guard sequence"
%% is constructed by "guard expressions" (seprated by ",").
%%
%% In other words, ";" is like "or" in guard, "," is like "and",
%% and "," has higher priority
%%-----------------------------------------------------------------------------
X = fun(A) when A > 3, A < 5; A > 8, A < 10 -> A end.
%> #Fun<erl_eval.6.128620087>

X(1).
%> ** exception error: no function clause matching

X(4).
%> 4

X(6).
%> ** exception error: no function clause matching

X(9).
%> 9

X(11).
%> ** exception error: no function clause matching


%%-----------------------------------------------------------------------------
%% character
%% Erlang has no character or string, it's integer and list.
%%-----------------------------------------------------------------------------
$c.
%> 99

$\r.
%> 13

$\n.
%> 10

[$a|"bcd"].
%> "abcd"

["a"|"bcd"].
%> ["a",98,99,100]


%%-----------------------------------------------------------------------------
%% element & lists:nth, one for list, one for tuple
%%    nth is not built-in, because usually, you should not use nth, it's slow
%%
%% but for tuple, select element through index is fast and normal,
%% so `element(N, L)` is built-in.
%%-----------------------------------------------------------------------------
lists:nth(2, [a,b,c,d,e]).
%> b

element(2, {a,b,c,d,e}).
%> b


%%-----------------------------------------------------------------------------
%% there is no "reduce" in erlang, it's called "fold"
%%-----------------------------------------------------------------------------
lists:foldl(fun(X, V) -> [X | V] end, [], [1,2,3]).
%> [3,2,1]

lists:foldr(fun(X, V) -> [X | V] end, [], [1,2,3]).
%> [1,2,3]


%%-----------------------------------------------------------------------------
%% SYNTAX SUGAR of map
%% Suggestion:
%%      use "=>" only when you want to create a new map
%%      use ":=" when possible
%%-----------------------------------------------------------------------------
%% create:
Me = #{name=>"wittyfox",age=>19}.
%> #{age => 19,name => "wittyfox"}

%% update:
Me#{age=>20}.
%> #{age => 20,name => "wittyfox"}

%% if you write a wrong key:
Me#{aeg=>20}.
%> #{aeg => 20,age => 19,name => "wittyfox"}

%% if you do NOT want to add element by accident, use ":=" instead of "=>"
Me#{aeg:=20}.
%> ** exception error: {badkey,aeg}
%    in function  maps:update/3
%       called as maps:update(aeg,20,#{age => 19,name => "wittyfox"})

%% pattern match: have to use ":="
#{age:=Age} = Me.
%> #{age => 19,name => "wittyfox"}
Age.
%> 19


%%-----------------------------------------------------------------------------
%% get and update
%% the default value for get is after map, while the default value
%% for update_with is before the map
maps:get(a, #{a=>1,b=>2}).
%> 1

maps:get(c, #{a=>1,b=>2}, 3).
%> 3

maps:update(a, 3, #{a=>1,b=>2}).
%> #{a => 3,b => 2}

maps:update_with(c, fun(V) -> V + 1 end, 3, #{a=>1,b=>2}).
%> #{a => 1,b => 2,c => 3}


%%-----------------------------------------------------------------------------
%% "map", "fold", "with", "without"
%% use "maps:to_list/1" transform to list and handle things as list, then
%% use "maps:from_list/1" transform back to map.

maps:map(fun(X, Y) -> io:format("~p => ~p~n", [X,Y]) end, Me).
%> age => 19
%  name => "wittyfox"
%  #{age => ok,name => ok}

maps:fold(fun(X, Y, V) -> V + 1 end, 0, Me).
%> 2


%% select part of a map
maps:with([], Me).
%> #{}

maps:with([age], Me).
%> #{age => 19}

% non-exist key is accepted
maps:with([aeg], Me).
%> #{}

maps:without([], Me).
%> #{age => 19,name => "wittyfox"}

maps:without([age], Me).
%> #{name => "wittyfox"}

% non-exist key is accepted
maps:without([age,neme], Me).
%> #{name => "wittyfox"}


%%-----------------------------------------------------------------------------
%% in pattern matching, #{} will match all maps
%%-----------------------------------------------------------------------------
case #{a=>1} of #{} -> "!!!"; _ -> ok end.
%> "!!!"


%%-----------------------------------------------------------------------------
%% list > tuple > atom > number
%%-----------------------------------------------------------------------------
[1,2,3] > {1,2,3}
%> true

lists:sort([a,b,"abc",{1,2,3},5]).
%> [5,a,b,{1,2,3},"abc"]


%%-----------------------------------------------------------------------------
%% pre-defined macros: ?MODULE, ?FILE, ?LINE
%%-----------------------------------------------------------------------------


%%-----------------------------------------------------------------------------
%% qlc
%% `qlc:q` is not a real function, it is a parse_transform
%%-----------------------------------------------------------------------------
%% To use `qlc:q` the following compile option is needed in the source file:
-compile({parse_transform,qlc})

QH = qlc:q([{X,Y} || X<-[a,b],Y<-[1,2]]).
%> {qlc_handle,{qlc_lc,#Fun<erl_eval.20.128620087>,
%                      {qlc_opt,false,false,-1,any,[],any,524288,allowed}}}

qlc:e(QH).
%> [{a,1},{a,2},{b,1},{b,2}]

qlc:q([{a,1},{a,2},{b,1},{b,2}]).
%> ** exception error: bad argument


%%-----------------------------------------------------------------------------
%% binary
%% !!
%% a binary field without size is only allowed at the end of a binary pattern
%%
%%-----------------------------------------------------------------------------
<<1,2,A:2/binary,B/binary>> = <<1,2,3,4,5,6,7,8>>.
%> <<1,2,3,4,5,6,7,8>>

A.
%> <<3,4>>

B.
%> <<5,6,7,8>>

%% These 2 are similar: (both of them are friendly for recursion)
<<A,B,C/binary>>, [A,B|C]


%%-----------------------------------------------------------------------------
%% the AST of a function
%%-----------------------------------------------------------------------------
%% function contains clauses, a clause is like:
%%  {clause, Line, [Args], [GuardSeqs], [Body]}

F = "blah([A|B]) when A > 0, A < 5; A > 9, A < 11 -> B * 3.".

erl_parse:parse_form(element(2, erl_scan:string(F))).
%> {ok,{function,1,blah,1,
%       [{clause,1,
%         [{cons,1,{var,1,'A'},{var,1,'B'}}],
%         [[{op,1,'>',{var,1,'A'},{integer,1,0}},
%           {op,1,'<',{var,1,'A'},{integer,1,5}}],
%          [{op,1,'>',{var,1,'A'},{integer,1,9}},
%           {op,1,'<',{var,1,'A'},{integer,1,11}}]],
%         [{op,1,'*',{var,1,'B'},{integer,1,3}}]}]}}

erl_parse:parse_form(element(2, erl_scan:string("blah() -> 3."))).
%> {ok,{function,1,blah,0,[{clause,1,[],[],[{integer,1,3}]}]}}


%%-----------------------------------------------------------------------------
%% try...of...catch...after...end
%%-----------------------------------------------------------------------------
%% There can be multiple expressions in try, which is invalid in case:
case 1,2,3,4,5 of 5 -> true end.
%> * 1: syntax error before: ','

try 1,2,3,4,5 of 5 -> true catch _ -> error end.
%> true

%% try can not be used without after or catch
try 1 of 1 -> true end.
%> * 1: syntax error before: 'end'

try 1 of 1 -> true catch _ -> error end.
%> true


%% In try...of...catch...after...
%% the "after" part will always be executed, even if the "of" part
%% or "catch" part raises an exception.
try 1/0
catch error:_ -> nothing
after io:format("<<<after printing>>>~n")
end.
%> <<<after printing>>>
%  nothing

try 1/0
catch error:_ -> 1/0
after io:format("<<<after printing>>>~n")
end.
%> <<<after printing>>>
%  ** exception error: an error occurred when evaluating an arithmetic expression


%% In core erlang,
%% a "try" with "after" is compiled a "try" with "catch".
%% e.g. try A() after B() end  -->  try A(), B() catch B() end
%%
%% And a "try" with both "catch" and "after"
%% is compiled into 2 "try" (nested).


%% In other languages who don't have the "of" part, the exception could be
%% thrown by any expression in the "try" part.
%% Erlang solved some of this problem by introducing the "of" part.
%%
%% When "catch" part is evaluated, you are sure that:
%% 1. the exception is not thrown by the "of" part.
%% 2. the "of" part is not evaluated.
%%
%% Because exceptions in "of" part will not be caught by "catch" part.
%%
try 1/0 of _ -> 1 catch error:Any -> Any end.
%> badarith

try 1 of _ -> 1/0 catch error:Any -> Any end.
%> ** exception error: an error occurred when evaluating an arithmetic expression


%%-----------------------------------------------------------------------------
%% Since R17, "fun" can have name. (good for defining recursive function)
%%-----------------------------------------------------------------------------
F = fun X(0) -> 1; X(N) -> N * X(N - 1) end.
%> #Fun<erl_eval.30.128620087>

F(10).
%> 3628800


%%-----------------------------------------------------------------------------
%% process operations
%%-----------------------------------------------------------------------------
%% list all processes
erlang:processes().
%> [<0.0.0>,<0.1.0>,<0.2.0>,<0.3.0>,...]

%% get information of a certain process
erlang:process_info(self()).
%> [{current_function,{erl_eval,do_apply,6}},...]

%% get a certain infomration of a process
erlang:process_info(self(), message_queue_data).
%> {message_queue_data,on_heap}

erlang:process_info(self(), total_heap_size).
%> {total_heap_size,13544}

%% list all registered processes
erlang:registered().
%> [rex,erts_code_purger,kernel_refc,kernel_sup,init,...]

%% read process dictionary of any processes
erlang:process_info(self(), dictionary).
%> {dictionary,[]}


%%-----------------------------------------------------------------------------
%% get release version
%%-----------------------------------------------------------------------------
erlang:system_info(otp_release).
%> "22"

erlang:system_info(wordsize).
%> 8


%%-----------------------------------------------------------------------------
%% ETS(Erlang Term Storage), DETS(Disk ETS)
%%-----------------------------------------------------------------------------
% create:
ets:new(...)
dets:open_file(...)

% insert
ets:insert(TableId, X)  % X is a tuple or a list of tuple

% lookup
ets:lookup(TableId, Key)  % return a list of tuple

% delete
ets:delete(TableId)


%%-----------------------------------------------------------------------------
%% the filename of an module
%%-----------------------------------------------------------------------------
code:which(filename).
%> "/usr/lib/erlang/lib/stdlib-3.7.1/ebin/filename.beam"

filename:dirname(code:which(filename)).
%> "/usr/lib/erlang/lib/stdlib-3.7.1/ebin"

%% list all loaded modules
code:all_loaded().
%> [{io,"/usr/lib/erlang/lib/stdlib-3.7.1/ebin/io.beam"},
%   {application,"/usr/lib/erlang/lib/kernel-6.2/ebin/application.beam"},
%   {prim_net,preloaded},
%   ...]
%%
%% elements returned will be
{modname,"/path/to/module.beam"}
%or
{modname,preloaded}


%% get the path to the priv directory in an application.
%%   (rebar will copy it from source to the build destination)
code:priv_dir(blah).
%> "/home/prj/blah/_build/default/lib/blah/priv"

%% it is same as
code:lib_dir(blah, priv).
%> "/home/prj/blah/_build/default/lib/blah/priv"

code:lib_dir(mnesia).
%> "/usr/local/lib/erlang/lib/mnesia-4.16.2"

code:lib_dir().
%> "/usr/local/lib/erlang/lib"

code:root_dir().
%> "/usr/local/lib/erlang"

%% !!!
%% module name conflict can be detected by "code:clash()".
%% for example, I got a "lists.beam" in the current directory
code:clash().
%  ** ./lists.beam hides /usr/local/lib/erlang/lib/stdlib-3.11.2/ebin/lists.beam
%  ** Found 1 name clashes in code paths
%> ok

%% erlang has a way to avoid the clash problem (sticky directory)
l(lists).
%  =ERROR REPORT==== 4-Apr-2020::01:22:56.321235 ===
%  Can't load module 'lists' that resides in sticky dir
%
%> {error,sticky_directory}


%% !!!
%% there is a dangerous way to do dangerous things

code:which(maps).
%> "/usr/local/lib/erlang/lib/stdlib-3.11.2/ebin/maps.beam"

code:unstick_dir("/usr/local/lib/erlang/lib/stdlib-3.11.2/ebin").
%> ok

c(maps).
%> {ok,maps}

maps:from_list([{a,1},{b,2}]).
%  ** exception error: undefined function maps:iterator/1
%  ...


%% !!!
%% files like "lists.beam", "maps.beam" in the current directory can make
%% erl crash at startup.
%% the sticky mechanism can only protect erts while it is running.



%%-----------------------------------------------------------------------------
%% format
%%-----------------------------------------------------------------------------
%% the format  ~<FieldWidth>.<Precision>.<Pad><Mod>
io:format("~10.3.0f~n", [math:pi()]).
%  000003.142
%> ok

io:format("~10.3. f~n", [math:pi()]).
%       3.142
%> ok

%% when the width is not enough, "***..." will be printed
io:format("~7.. w~n", [{1,2,3}]).
%  {1,2,3}
%> ok

io:format("~6.. w~n", [{1,2,3}]).
%  ******
%> ok


%%-----------------------------------------------------------------------------
%% fields in record can have default values by using the "_"
%%-----------------------------------------------------------------------------
-record(blah, {a,b,c}).

io:format("~p~n", [#blah{a=1,_=default}]).
%  {blah,1,default,default}
%> ok


%%-----------------------------------------------------------------------------
%% regular expression
%%-----------------------------------------------------------------------------
re:run("hello, wallace", "hello, ([^\s]+)").
%> {match,[{0,14},{7,7}]}

re:run("hello, wallace", "hello, ([^\s]+)", [{capture,all,list}]).
%> {match,["hello, wallace","wallace"]}

re:run("hello, wallace", "hello, ([^\s]+)", [{capture,all_but_first,list}]).
%> {match,["wallace"]}

%% argument1 and agument2 of re:run are both iodata (iolist | binary)
re:run(<<"hello, wallace">>, "hello, ([^\s]+)").
%> {match,[{0,14},{7,7}]}

re:run("hello, wallace", <<"hello, ([^\s]+)">>).
%> {match,[{0,14},{7,7}]}


%%-----------------------------------------------------------------------------
%% !, process and port
%%-----------------------------------------------------------------------------
%% erlang:send/2 is same as the send operator("!")
erlang:send(Dest, Msg). %> same as: Dest ! Msg.

erlang:port_command(Port, Data).
%% is similar to:
Port ! {PortOwner,{command,Data}}
%% but not the same ! It's synchronous, the error behavior is different, etc.


%%-----------------------------------------------------------------------------
%% 2 ways to use timer
%%-----------------------------------------------------------------------------
erlang:send_after(0, self(), "test").
%> #Ref<0.2007321174.2698510337.136265>
receive A -> A end.
%> "test"

erlang:start_timer(0, self(), "test").
%> #Ref<0.2007321174.2698510337.136278>
receive A -> A end.
%> {timeout,#Ref<0.2007321174.2698510337.136278>,"test"}


